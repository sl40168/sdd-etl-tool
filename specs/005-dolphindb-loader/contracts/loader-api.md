# Loader API Contract

**Feature Branch**: `005-dolphindb-loader`
**Date**: 2026-01-11
**Status**: Phase 1 Design

## Overview

This document defines the common Loader API contract for the ETL tool. The Loader API provides an extensible interface for loading transformed data into target systems (databases, data warehouses, etc.). The first implementation will target DolphinDB using its Java API, with future implementations possible for MySQL, PostgreSQL, or other systems.

## Core Interface

### `com.sdd.etl.loader.api.Loader`

```java
public interface Loader {
    /**
     * Initialize the loader with configuration.
     * @param config LoaderConfiguration containing connection details, sorting fields, etc.
     * @throws LoaderConfigurationException if configuration is invalid
     */
    void init(LoaderConfiguration config) throws LoaderConfigurationException;

    /**
     * Create temporary tables for intermediate storage during loading.
     * Temporary tables are used to hold sorted data before loading into target tables.
     * @param targetTables List of target tables to create temporary counterparts for
     * @throws TemporaryTableCreationException if any temporary table cannot be created
     */
    void createTemporaryTables(List<TargetTable> targetTables) throws TemporaryTableCreationException;

    /**
     * Sort the provided TargetDataModel according to the configured sorting fields.
     * Sorting is performed externally (disk-based) if data exceeds memory limits.
     * @param dataModel The data model containing records to be sorted
     * @return Sorted TargetDataModel (may be the same instance if already sorted)
     * @throws SortingException if sorting fails due to IO errors or insufficient resources
     */
    TargetDataModel sortData(TargetDataModel dataModel) throws SortingException;

    /**
     * Load sorted data into target tables sequentially by data type.
     * For each target table, data is loaded from its corresponding temporary table.
     * @param sortedData The sorted TargetDataModel
     * @param targetTables List of target tables to load into
     * @throws LoadingException if any loading operation fails
     */
    void loadData(TargetDataModel sortedData, List<TargetTable> targetTables) throws LoadingException;

    /**
     * Validate that data was loaded correctly (e.g., row counts match, no corruption).
     * @param targetTables List of target tables to validate
     * @throws ValidationException if validation fails
     */
    void validateLoad(List<TargetTable> targetTables) throws ValidationException;

    /**
     * Clean up temporary tables after successful validation.
     * @param targetTables List of target tables whose temporary counterparts should be dropped
     * @throws CleanupException if cleanup fails
     */
    void cleanupTemporaryTables(List<TargetTable> targetTables) throws CleanupException;

    /**
     * Shutdown the loader, releasing any resources (e.g., database connections).
     */
    void shutdown();
}
```

## Supporting Classes

### `com.sdd.etl.loader.api.LoaderConfiguration`

```java
public class LoaderConfiguration {
    private String connectionUrl;
    private String username;
    private String password;
    private List<String> sortFields;          // Field names to sort by (e.g., ["date", "symbol"])
    private long maxMemoryBytes = 256 * 1024 * 1024; // 256 MB default for in‑memory sorting
    private String temporaryTablePrefix = "temp_";
    private Map<String, String> targetTableMappings; // dataType -> tableName (immutable during ETL)
    private Map<String, String> additionalProperties;

    // Constructors, getters, setters, validation methods
}
```

### `com.sdd.etl.loader.api.TargetDataModel`

```java
public class TargetDataModel {
    private List<Record> records;
    private Schema schema;

    // Getters, setters, iterator
}
```

### `com.sdd.etl.loader.api.TargetTable`

```java
public class TargetTable {
    private String name;
    private String dataType;           // e.g., "quote", "trade"
    private List<ColumnDefinition> columns;
    private String temporaryTableName; // Generated by createTemporaryTables

    // Getters, setters
}
```

## Exception Hierarchy

All loader exceptions extend `LoaderException` (runtime exception).

```
LoaderException
├── LoaderConfigurationException
├── TemporaryTableCreationException
├── SortingException
├── LoadingException
├── ValidationException
└── CleanupException
```

Each exception includes:
- A descriptive message
- The target table name (if applicable)
- The original cause (if any)
- Suggested user action

## Integration Points

### LoadSubprocess Integration

The `LoadSubprocess` will:
1. Instantiate the configured `Loader` implementation (e.g., `DolphinDBLoader`).
2. Call `init()` with configuration from the INI file.
3. Call `createTemporaryTables()` for all target tables.
4. Call `sortData()` on the transformed data model.
5. Call `loadData()` with sorted data and target tables.
6. Call `validateLoad()` to confirm successful loading.
7. If any step fails, propagate the exception (which will break the ETL process).

### CleanSubprocess Integration

The `CleanSubprocess` will:
1. Obtain the same `Loader` instance (shared via context).
2. Call `cleanupTemporaryTables()` for all target tables.
3. Call `shutdown()` after cleanup.

## Configuration

### INI File Section

```ini
[loader]
connection.url = localhost:8848
connection.username = admin
connection.password = 123456
sort.fields = date,symbol
max.memory.mb = 256
temporary.table.prefix = temp_
target.table.mappings = XbondQuote:xbond_quote_stream_temp,XbondTrade:xbond_trade_stream_temp,BondFutureQuote:fut_market_price_stream_temp
```

## Lifecycle

1. **Initialization**: Loader reads configuration and establishes connection.
2. **Temporary Table Creation**: Before loading, temporary tables are created with same schema as target tables.
3. **Sorting**: Data is sorted by configured fields (external sort if needed).
4. **Loading**: Sorted data is inserted into temporary tables, then moved to target tables.
5. **Validation**: Row counts and integrity checks are performed.
6. **Cleanup**: Temporary tables are dropped after successful validation.
7. **Shutdown**: Connection is closed.

## Error Handling

- Any exception thrown by the loader will cause the ETL process to stop immediately.
- The exception message must be descriptive enough for manual intervention.
- Temporary tables are left intact on failure to allow forensic analysis.
- The user must resolve the issue and restart the ETL process.

## Extensibility

To add a new target system:
1. Implement the `Loader` interface.
2. Add a factory method in `LoaderFactory`.
3. Update INI configuration parser to recognize the new loader type.
4. Write unit and integration tests.

Example future loader types:
- `MySQLloader`
- `PostgreSQLLoader`
- `BigQueryLoader`

## Feature Requirements Mapping

| FR # | Requirement | Contract Coverage |
|------|-------------|-------------------|
| FR-001 | Common Loader API for extensibility | ✅ Core interface definition |
| FR-002 | Use DolphinDB Java API | ✅ Implementation‑specific contract (separate) |
| FR-003 | Daily ETL process with temporary tables | ✅ createTemporaryTables, cleanupTemporaryTables |
| FR-004 | Sort TargetDataModel by given fields | ✅ sortData method |
| FR-005 | Load data sequentially by data type | ✅ loadData with targetTables |
| FR-006 | Integrate with LoadSubprocess | ✅ Integration points section |
| FR-007 | Integrate with CleanSubprocess | ✅ Integration points section |
| FR-008 | Any loading exception breaks ETL process | ✅ Error handling section |
| FR-009 | Target table names MUST be configurable and remain unchanged during the entire ETL process | ✅ LoaderConfiguration.targetTableMappings field and INI mapping example |

## Source

- Feature Specification: FR-001 through FR-009
- User Stories: US1 (Load Data via Java API), US2 (Integrate with Subprocesses), US3 (Handle Exceptions)
- Edge Cases: DolphinDB unavailability, duplicate data, null values in sort fields, memory limits, partial failures
- Clarifications: Authentication via username/password, skip records with null sort fields, external sorting when memory exceeded, keep successful data on partial failure, temporary table names immutable